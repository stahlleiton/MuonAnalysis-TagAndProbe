#ifndef helper_h
#define helper_h

#include "TStyle.h"
#include "TGraphAsymmErrors.h"
#include "TAxis.h"
#include "TRandom3.h"
#include "TH1.h"
#include "TRatioPlot.h"
#include <map>

// define the efficiency types
const std::vector<std::string> effType = { "Track", "TrackID", "TrackerMuon", "PFGlobalMuon", "MuonID", "Trigger", "Full" };

// define the bins
typedef std::pair<double, double> binT;
typedef std::pair<binT, binT> anaBinT;
const std::vector<double> ptBins = {15., 20., 25., 30., 40., 50., 60., 70., 80., 100.};
const std::map<binT, std::vector<double> > etaPtBins =
  {
   { {0.0, 0.9} , ptBins },
   { {0.9, 1.2} , ptBins },
   { {0.0, 1.2} , ptBins },
   { {1.2, 1.6} , ptBins },
   { {1.6, 2.1} , ptBins },
   { {1.2, 2.1} , ptBins },
   { {2.1, 2.4} , ptBins },
   { {15., 200.}, {-2.4, -2.1, -1.6, -1.2, -0.9, 0.9, 1.2, 1.6, 2.1, 2.4} }
  };
const std::vector<binT> centBins = { {0., 10.}, {10., 20.}, {0., 20.}, {20., 100.}, {0., 100.} };

bool IsAccept(Double_t pt, Double_t eta)
{

     //return(1);
     //return (TMath::Abs(eta) < 2.4); 

   return (TMath::Abs(eta) < 2.4 &&
         (    ( TMath::Abs(eta) < 1.0 && pt >= 3.4 ) ||
              (  1.0 <= TMath::Abs(eta) && TMath::Abs(eta) < 1.5 && pt >= 5.8-2.4*TMath::Abs(eta) ) ||
              (  1.5 <= TMath::Abs(eta) && pt >= 3.3667 - 7.0/9.0*TMath::Abs(eta)) ));
};

Int_t getMCHiBinFromhiHF(const Double_t hiHF) {
  const Int_t nBins = 200; // table of bin edges
  const Double_t binTable[nBins+1] = {0, 12.2187, 13.0371, 13.7674, 14.5129, 15.2603, 16.0086, 16.7623, 17.5335, 18.3283, 19.1596, 19.9989, 20.8532, 21.7297, 22.6773, 23.6313, 24.6208, 25.6155, 26.6585, 27.7223, 28.8632, 30.041, 31.2865, 32.5431, 33.8655, 35.2539, 36.6912, 38.2064, 39.7876, 41.4818, 43.2416, 45.0605, 46.9652, 48.9918, 51.1, 53.2417, 55.5094, 57.9209, 60.3817, 62.9778, 65.6099, 68.4352, 71.3543, 74.4154, 77.6252, 80.8425, 84.1611, 87.7395, 91.3973, 95.1286, 99.0571, 103.185, 107.482, 111.929, 116.45, 121.178, 126.081, 130.995, 136.171, 141.612, 147.298, 153.139, 159.419, 165.633, 172.114, 178.881, 185.844, 192.845, 200.244, 207.83, 215.529, 223.489, 231.878, 240.254, 249.319, 258.303, 267.508, 277.037, 286.729, 296.845, 307.458, 317.882, 328.787, 340.074, 351.295, 362.979, 375.125, 387.197, 399.604, 412.516, 425.683, 439.001, 452.667, 466.816, 481.007, 495.679, 510.588, 526.138, 541.782, 557.641, 574.141, 591.071, 608.379, 626.068, 643.616, 661.885, 680.288, 699.449, 718.925, 738.968, 758.983, 779.459, 800.376, 821.638, 843.555, 865.771, 888.339, 911.031, 934.979, 958.56, 982.582, 1007.02, 1031.9, 1057.81, 1084.01, 1111.71, 1138.21, 1165.72, 1193.73, 1221.65, 1251.51, 1281.23, 1311.01, 1341.1, 1372.4, 1404.29, 1436.52, 1468.65, 1501.91, 1535.56, 1569.69, 1604.69, 1640.65, 1676.05, 1712.62, 1749.28, 1787.43, 1825.89, 1866.07, 1906.58, 1947.84, 1989.66, 2031.4, 2072.8, 2115.32, 2159.5, 2205.23, 2252.68, 2298.58, 2345.65, 2393.36, 2442.87, 2491.45, 2541.04, 2592.81, 2645.52, 2699.1, 2753.29, 2807.93, 2864.37, 2922.6, 2979.42, 3038.68, 3098.72, 3159.29, 3221.66, 3285.9, 3350.95, 3415.81, 3482.69, 3552.62, 3623.61, 3694.63, 3767.25, 3840.28, 3917.04, 3993.66, 4073.36, 4154.33, 4238.13, 4322.21, 4409.83, 4498.89, 4589.72, 4681.56, 4777.09, 4877.95, 4987.05, 5113.04, 5279.58, 6242.82};
  Int_t binPos = -1;
  for(int i = 0; i < nBins; ++i){
    if(hiHF >= binTable[i] && hiHF < binTable[i+1]){
      binPos = i;
      break;
    }
  }
  binPos = nBins - 1 - binPos;
  return (Int_t)(200*((Double_t)binPos)/((Double_t)nBins));
}

double findCenWeight(const int Bin) {
  double NCollArray[40]={
    1747.8600, 1567.5300, 1388.3900, 1231.7700, 1098.2000, 980.4390, 861.6090, 766.0420, 676.5150, 593.4730,
    521.9120, 456.5420, 398.5460, 346.6470, 299.3050, 258.3440, 221.2160, 188.6770, 158.9860, 134.7000,
    112.5470, 93.4537, 77.9314, 63.5031, 52.0469, 42.3542, 33.9204, 27.3163, 21.8028, 17.2037,
    13.5881, 10.6538, 8.3555, 6.4089, 5.1334, 3.7322, 3.0663, 2.4193, 2.1190, 1.7695
  };
  return(NCollArray[Bin]);
};

Double_t findNcoll(int hiBin) {
   const int nbins = 200;
   const Double_t Ncoll[nbins] = {1976.95, 1944.02, 1927.29, 1891.9, 1845.3, 1807.2, 1760.45, 1729.18, 1674.8, 1630.3, 1590.52, 1561.72, 1516.1, 1486.5, 1444.68, 1410.88, 1376.4, 1347.32, 1309.71, 1279.98, 1255.31, 1219.89, 1195.13, 1165.96, 1138.92, 1113.37, 1082.26, 1062.42, 1030.6, 1009.96, 980.229, 955.443, 936.501, 915.97, 892.063, 871.289, 847.364, 825.127, 806.584, 789.163, 765.42, 751.187, 733.001, 708.31, 690.972, 677.711, 660.682, 640.431, 623.839, 607.456, 593.307, 576.364, 560.967, 548.909, 530.475, 519.575, 505.105, 490.027, 478.133, 462.372, 451.115, 442.642, 425.76, 416.364, 405.154, 392.688, 380.565, 371.167, 360.28, 348.239, 340.587, 328.746, 320.268, 311.752, 300.742, 292.172, 281.361, 274.249, 267.025, 258.625, 249.931, 240.497, 235.423, 228.63, 219.854, 214.004, 205.425, 199.114, 193.618, 185.644, 180.923, 174.289, 169.641, 161.016, 157.398, 152.151, 147.425, 140.933, 135.924, 132.365, 127.017, 122.127, 117.817, 113.076, 109.055, 105.16, 101.323, 98.098, 95.0548, 90.729, 87.6495, 84.0899, 80.2237, 77.2201, 74.8848, 71.3554, 68.7745, 65.9911, 63.4136, 61.3859, 58.1903, 56.4155, 53.8486, 52.0196, 49.2921, 47.0735, 45.4345, 43.8434, 41.7181, 39.8988, 38.2262, 36.4435, 34.8984, 33.4664, 31.8056, 30.351, 29.2074, 27.6924, 26.7754, 25.4965, 24.2802, 22.9651, 22.0059, 21.0915, 19.9129, 19.1041, 18.1487, 17.3218, 16.5957, 15.5323, 14.8035, 14.2514, 13.3782, 12.8667, 12.2891, 11.61, 11.0026, 10.3747, 9.90294, 9.42648, 8.85324, 8.50121, 7.89834, 7.65197, 7.22768, 6.7755, 6.34855, 5.98336, 5.76555, 5.38056, 5.11024, 4.7748, 4.59117, 4.23247, 4.00814, 3.79607, 3.68702, 3.3767, 3.16309, 2.98282, 2.8095, 2.65875, 2.50561, 2.32516, 2.16357, 2.03235, 1.84061, 1.72628, 1.62305, 1.48916, 1.38784, 1.28366, 1.24693, 1.18552, 1.16085, 1.12596, 1.09298, 1.07402, 1.06105, 1.02954};
   return Ncoll[hiBin];
};

TH1F *g2h(TGraphAsymmErrors *g, double def=1e-3) {
   int n = g->GetN();
   double *x = g->GetX();
   double *y = g->GetY();
   double *exl = g->GetEXlow();
   double *exh = g->GetEXhigh();
   double *eyl = g->GetEYlow();
   double *eyh = g->GetEYhigh();
   double *bins = new double[n+2];
   bins[0] = (x[0]>=0. ? 0. : x[0]*1.1);
   for (int i=0; i<n; i++) bins[i+1] = x[i]-exl[i];
   bins[n+1] = x[n-1]+exh[n-1];
   TH1F *ans = new TH1F(Form("tmp%i",gRandom->Integer(1e9)),"tmp",n+1,bins);
   ans->SetBinContent(1,def);
   ans->SetBinError(1,def/5.);
   for (int i=0; i<n; i++) {
      ans->SetBinContent(i+2,y[i]);
      ans->SetBinError(i+2,(eyl[i]+eyh[i])/2.);
   }
   ans->SetLineColor(g->GetLineColor());
   ans->SetMarkerColor(g->GetMarkerColor());
   ans->SetMarkerStyle(g->GetMarkerStyle());
   ans->GetYaxis()->SetTitle("Efficiency");
   if (x[0]>2.4) { ans->GetXaxis()->SetTitle("p_{T} [GeV/c]"); }
   else { ans->GetXaxis()->SetTitle("#eta"); }
   delete[] bins;
   return ans;
};

void setTRatioPlotStyle(TRatioPlot *tr) {
   gStyle->SetOptStat(0);
   tr->SetH1DrawOpt("E");
   tr->SetH2DrawOpt("E");
   tr->Draw();
   tr->GetLowerRefXaxis()->SetTitleOffset(0.9);
   tr->SetLowBottomMargin(0.4);
   tr->SetRightMargin(0.05);
   tr->GetUpperRefYaxis()->SetRangeUser(0,1.1);
   tr->GetUpperRefXaxis()->SetRangeUser(15, 100);
   tr->GetLowerRefYaxis()->SetRangeUser(0.89,1.11);
   tr->GetLowerRefXaxis()->SetRangeUser(15, 200);
   tr->GetLowerRefYaxis()->SetNdivisions(503,kFALSE);
   tr->GetUpperRefYaxis()->SetTitle("Efficiency");
   tr->GetLowerRefYaxis()->SetTitle("trd / tnp");
   tr->GetUpperRefYaxis()->SetTitleOffset(0.9);
   tr->GetLowerRefYaxis()->SetTitleOffset(0.9);
   tr->RangeAxisChanged();
};
#endif // #ifndef helper_h
